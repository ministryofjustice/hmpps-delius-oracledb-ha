- name: Steps on Primary Only
  when: 
     - inventory_hostname == groups[ primary ][0]
     - not password_rotation
  block:

      - name: Get Configuration Name
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / "show configuration;" | grep "^Configuration - " | cut -f3 -d' '
        register: get_ConfigurationName
        changed_when: false

      - name: Set Configuration Name
        set_fact:
            configuration_name: "{{ get_ConfigurationName.stdout | trim }}"

- name: Share Configuration Name with all Hosts
  set_fact:
     configuration_name: "{{ hostvars[groups[primary][0]]['configuration_name'] }}"
  when: not password_rotation

- name: Steps on Primary Only
  when: 
     - inventory_hostname == groups[ primary ][0]
  block:

      - name: Get Configuration-Wide Service Name
        shell: |
              . ~/.bash_profile
              dgmgrl  / "show configuration ConfigurationWideServiceName" | awk -F= '{print $2}'
        register: get_ConfigurationWideServiceName
        changed_when: false

      - name: Set Configuration-Wide Service Name
        set_fact:
            configuration_wide_service_name: "{{ get_ConfigurationWideServiceName.stdout_lines[-1] | default('') | replace(\"'\",'') |  trim }}"
        
      # Do not use configuration_wide_service_name in the when conditition as it will mutate before the end of the block
      - name: Fix Undefined Configuration-Wide Service Name
        when: ( get_ConfigurationWideServiceName.stdout_lines[-1] | default('') | replace("'",'') |  trim ) == ''
        block:

            - name: Set New Configuration-Wide Service Name
              set_fact:
                  configuration_wide_service_name: "{{ database_primary_unique }}_CFG"

            - name: Configure Configuration-Wide Service Name
              shell: |
                    . ~/.bash_profile
                    dgmgrl  / "edit configuration set property ConfigurationWideServiceName='{{ configuration_wide_service_name }}'"

- name: Share Configuration Wide Service Name with all Hosts
  set_fact:
     configuration_wide_service_name: "{{ hostvars[groups[primary][0]]['configuration_wide_service_name'] }}"

- name: Get Oracle Base
  shell: |
    . ~/.bash_profile
    echo $ORACLE_BASE
  register: oracle_base_result
  run_once: true
  changed_when: false  

- name: Set Oracle Base
  set_fact: 
    oracle_base: "{{ oracle_base_result.stdout }}"

- name: Define Location for Oracle Wallet
  set_fact:
    wallet_dir: "{{ oracle_base }}/wallets/dg_wallet"

# We do not need to do the following if we are only rotating the password as we assume that FSFO has already been configured
- name: Setup Connectivity
  when: not password_rotation
  block:

      - name: Add Optional HA1 TNS Address
        set_fact:
          ha1_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host1_tns }})(PORT = 1521))"
        when: (high_availability_count | int | default(0)) >= 1 

      - name: Add Optional HA2 TNS Address
        set_fact:
          ha2_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host2_tns }})(PORT = 1521))"
        when: (high_availability_count | int | default(0)) == 2 

      - name: Add Configuration-Wide Service TNS Names Alias
        blockinfile:
          create: yes
          path: '{{ oracle_database_oracle_home }}/network/admin/tnsnames.ora'  
          block: |

            {{ configuration_wide_service_name }} =
            (DESCRIPTION =
              (ADDRESS_LIST = 
                  (ADDRESS = (PROTOCOL = TCP)(HOST = {{ primary_host_tns }})(PORT = 1521)){{ ha1_address | default('') }}{{ ha2_address | default('') }})
                    (CONNECT_DATA =
                      (SERVER = DEDICATED) 
                      (SERVICE_NAME = {{ configuration_wide_service_name }})
                )
            )
          owner: "{{ rdbms_service_user.name }}"
          group: "{{ rdbms_service_user.group }}"
          marker: "# {mark} ANSIBLE MANAGED BLOCK ADD CONFIGURATION-WIDE SERVICE NAME"
        
      - name: Create Wallet Directory
        file: 
          path: "{{ wallet_dir }}"
          state: directory

      - name: Create Wallet if it does not already exist
        shell: |
              . ~/.bash_profile
              orapki wallet create -wallet {{ wallet_dir }} -auto_login_only
        args:
          creates: "{{ wallet_dir }}/cwallet.sso"
        register: orapki_out

      - name: Report Check
        debug:
            msg: "Checking if the credentials exist for {{ configuration_wide_service_name }} in the wallet"

      - name: Check if the Configuration-Wide Service Name is Already in the Wallet
        shell: |
                . ~/.bash_profile
                mkstore -wrl {{ wallet_dir }} -listCredential | grep -c ": {{ configuration_wide_service_name }} sys$" | cat
        register: get_configuration_wide_service_name_in_wallet
        changed_when: false

      - name: Add Wallet Location to SQLNET Config
        blockinfile:
          create: yes
          path: '{{ oracle_database_oracle_home }}/network/admin/sqlnet.ora'  
          block: |

            WALLET_LOCATION=(SOURCE=(METHOD=file)(METHOD_DATA=(DIRECTORY={{ wallet_dir }})))
            SQLNET.WALLET_OVERRIDE=true

          owner: "{{ rdbms_service_user.name }}"
          group: "{{ rdbms_service_user.group }}"
          marker: "# {mark} ANSIBLE MANAGED BLOCK ADD DATA GUARD WALLET"

- name: Get sys password from ssm parameter store
  shell: . /etc/environment && aws ssm get-parameters --region ${REGION} --with-decryption --name /${HMPPS_ENVIRONMENT}/${APPLICATION}/${HMPPS_ROLE}-database/db/oradb_sys_password | jq -r '.Parameters[].Value'
  register: get_sys_password
  changed_when: false
  no_log: true
  vars:
     ansible_aws_ssm_timeout: 60

- name: Initialize List of Data Guard Credentials
  set_fact:
      data_guard_credentials: "{{ [hostvars[groups[ primary ][0]]['database_primary_unique'] + '_CFG', hostvars[groups[ primary ][0]]['database_primary_unique']] }}"

- name: Add 1st Standby to Credentials List Where it Exists
  set_fact:
      data_guard_credentials: "{{ data_guard_credentials + [ hostvars[groups[ standby1 ][0]]['database_standby_unique'] ] }}"
  when: high_availability_count | int >= 1

- name: Add Optional 2nd Standby to Credentials List Where it Exists
  set_fact:
      data_guard_credentials: "{{ data_guard_credentials + [ hostvars[groups[ standby2 ][0]]['database_standby_unique']  ] }}"
  when: high_availability_count | int == 2

- debug: var=data_guard_credentials

- name: Initialize Password Update Count
  set_fact:
      password_update_count: 0

- name: Update Password in Data Guard Wallet
  include: update_data_guard_wallet_credentials.yml
  vars:
    credential_name: "{{ item }}"
    sys_password: "{{ get_sys_password.stdout }}"
  loop: "{{ data_guard_credentials }}"    

- name: Define Location for Observer Configuration
  set_fact:
      observer_config_dir: "{{ oracle_base }}/dg_observer"

# Do not repeat Observer Config setup if rotating passwords as we assume this has already been done
- name: Setup Observer Config
  when: not password_rotation
  block:

      - name: Create Observer Configuration Directory
        file:
            path: "{{ observer_config_dir }}"
            state: directory

      - name: Install Observer Configuration File
        template:
          src: observer.j2
          dest: "{{ observer_config_dir }}/observer.ora"

# We require the hostname (EC2 Hostname) as supplied by the hostname command as this is what is used by the Data Guard Broker to identify hosts
- name: Get Hostname
  shell: |
         hostname
  register: get_hostname
  changed_when: false
  vars:
     ansible_aws_ssm_timeout: 60

- name: Set Hostname
  set_fact:
      my_hostname: "{{ get_hostname.stdout }}"

- name: Define Name for CRS Resource for Observer
  set_fact:
      observer_resource: "dg.observer"

# Do not repeat CRS setup if rotating passwords as we assume this has already been done
- name: Setup CRS
  when: not password_rotation
  block:

      - name: Install CRS Resource Action Script to Control the Observer
        copy:
          src: observer.sh
          dest: "{{ observer_config_dir }}/observer.sh"
          mode: u+rwx
        
      - name: Install CRS Resource Attributes for Observer
        template:
          src: observer.config.j2
          dest: "{{ observer_config_dir }}/observer.config"
        vars:
          observer_script: "{{ observer_config_dir }}/observer.sh"
          ec2_hostname: "{{ my_hostname }}"
          db_service: "{{ database_primary_sid | default(database_standby_sid) | lower }}"
          ansible_aws_ssm_timeout: 60

- name: Check if CRS Resource Already Exists
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl status resource {{ observer_resource }} -p
  changed_when: false
  register: get_crs_resource

- name: Add CRS Resource for Observer
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl add resource {{ observer_resource }} -type cluster_resource -file {{ observer_config_dir }}/observer.config
  when: 
     - get_crs_resource.stdout is search('.*CRS-2613.*')
     - not password_rotation

# Whilst we are working on configuring / resetting the Observers we want to temporarily remove them from the control of CRS
# so that it does not attempt to restart the resources at a time not of our choosing
- name: Get Fast-Start Failover Status
  shell: |
        . ~/.bash_profile
        dgmgrl -silent / "show configuration;" | awk -F: '/Fast-Start Failover/{print $2}'
  register: get_fast_start_failover
  changed_when: false

# Disable Fast Start Failover before stopping Observers to prevent a failover attempt (Run from Primary)
- name: Disable Fast Start Failover
  shell: |
      . ~/.bash_profile
      dgmgrl / "disable fast_start failover;"
  when:
    - inventory_hostname == groups[ primary ][0]
    -  ( get_fast_start_failover.stdout | trim ) != 'Disabled'
  vars:
          ansible_aws_ssm_timeout: 60

# Setup steps only - do not change FSFO configuration during password rotation
- name: Steps on Primary Only
  when: 
     - inventory_hostname == groups[ primary ][0]
     - not password_rotation
  block:

      - name: Get Existing FSFO Health Conditions
        shell: |
                . ~/.bash_profile
                dgmgrl  / "show fast_start failover;" | awk '{if(flag==1){print $0}}/Health Conditions:/{flag=1}/^$/{flag=0}'
        register: get_fsfo_health_conditions
        changed_when: false

      - name: Generate Dictionary of FSFO Health Conditions
        set_fact:
            current_fsfo_health_conditions: "{{ current_fsfo_health_conditions | default({}) | combine({ ( item | regex_replace('(YES|NO)$','') | trim ) : ( item | regex_replace('^.*(YES|NO)$','\\1') ) }) }}"
        loop: "{{ get_fsfo_health_conditions.stdout_lines }}"

      - name: Enable Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'enable fast_start failover condition "{{ item }}";'
        loop:  "{{ target_fsfo_health_conditions | default([]) }}"
        when: 
          - (current_fsfo_health_conditions[item] | default('NO')) != 'YES'

      - name: Disable Unwanted Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'disable fast_start failover condition "{{ item }}";'
        loop:  "{{ current_fsfo_health_conditions.keys() }}"
        when:  
          - item not in ( target_fsfo_health_conditions | default([]) )
          - (current_fsfo_health_conditions[item] | default('NO')) == 'YES'

      - name: Get Observer Reconnection Attempt Interval
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration ObserverReconnect;' | awk -F= '{print $2}'
        register: get_ObserverReconnect
        changed_when: false

      - name: Set Observer Reconnection Attempt Interval
        set_fact:
            current_observer_reconnect: "{{ get_ObserverReconnect.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
        when: get_ObserverReconnect.stdout != ''

      - name: Configure Observer Reconnection Attempt Interval
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set property ObserverReconnect = {{ target_fsfo_observer_reconnect }};'
        when: ( target_fsfo_observer_reconnect | int ) != ( current_observer_reconnect | default(30) | int )

      - name: Get Fast Start Failover Timeout Threshold
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration FastStartFailoverThreshold;' | awk -F= '{print $2}'
        register: get_FSFOThreshold
        changed_when: false

      - name: Set Fast Start Failover Timeout Threshold
        set_fact:
            current_fsfo_threshold: "{{ get_FSFOThreshold.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

      - name: Show FSFO Threshold
        debug:
            msg: "Current FSFO Threshold:  {{  current_fsfo_threshold }}.   Target FSFO Threshold: {{ target_fsfo_threshold }}."

      - name: Configure Fast Start Failover Timeout Threshold if Different
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set property FastStartFailoverThreshold = {{ target_fsfo_threshold }};'
        when: ( target_fsfo_threshold | int ) != ( current_fsfo_threshold | int )

      # All databases which have a standby are run in Maximum Availability Mode
      - name: Get Protection Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration;' | awk -F: '/Protection Mode/{print $2}'
        register: get_ProtectionMode
        changed_when: false      

      - name: Set Protection Mode
        set_fact:
            current_protection_mode: "{{ get_ProtectionMode.stdout_lines[-1] |  trim }}"

      - name: Configure Protection Mode
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set protection mode as maxavailability;'
        when: current_protection_mode != 'MaxAvailability'

- name: Get FSFO Targets
  shell: |
          . ~/.bash_profile
           dgmgrl -silent / "show database verbose {{ database_primary_sid | default(database_standby_sid) }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
  register: get_FastStartFailoverTarget
  changed_when: false

- name: Set FSFO Targets
  set_fact:
      current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

# Much of the following steps are notionally set-up only; but we run them again during a password rotation to correct any misplacement of
# observers which may have occurred due to password changes causing automated changes in the configuration which we do not want.

- name: Initialize Databases Currently in Configuration
  set_fact:
      databases_in_configuration: []

- name: Initialize FSFO Targets
  set_fact:
      fsfo_targets: ''

- name: Get FSFO Targets
  include_tasks: determine-fsfo-targets.yml  
  vars:
     delegation_host: "{{ inventory_hostname }}"
     primary_hostname: "{{ groups[ primary ][0] }}"
     standby1_hostname:  "{{ groups[ standby1 ][0] }}"
     standby2_hostname:  "{{ groups[ standby2 ][0] | default('') }}"
     
- name: Configure FSFO Targets (New Standby)
  shell: |
         . ~/.bash_profile
         dgmgrl / "edit database {{ database_primary_sid | default(database_standby_sid) }} set property FastStartFailoverTarget='{{ fsfo_targets }}';"
  when: (fsfo_targets | lower ) != ( current_fsfo_targets | lower )

# If we have just added a new 2nd Standby it should be added as a Failover option to an existing 1st Standby
- name: Add New 2nd Standby as Failover Option for Existing 1st Standby
  when: 
     - standby_number | int == 2
     - ( hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower ) in databases_in_configuration
     - inventory_hostname == groups[ primary ][0]
  block:

      - name: Get FSFO Targets
        shell: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }};" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 1st Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl / "edit database {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] | lower }},{{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower }}';"
        when: (fsfo_targets | lower ) != (  hostvars[groups[ primary ][0]]['database_primary_sid'] + "," + hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower )
        register: configure_fsfo_1st
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"
        retries: 3
        delay: 60
        until: configure_fsfo_1st is not failed

# If we have just added a new 1st Standby it should be added as a Failover option to an existing 2nd Standby
# This block is unlikely to be called much.   It will only be called under the scenario that the 1st standby has been lost
# but the 2nd standby is still available, and the 1st standby is now being rebuilt
- name: Add New 1st Standby as Failover Option for Existing 2nd Standby
  when: 
     - standby_number | int == 1
     - high_availability_count | int > 1
     - ( hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower ) in databases_in_configuration
     - inventory_hostname == groups[ primary ][0]
  block:

      - name: Get FSFO Targets
        shell: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 2nd Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl  -silent / "edit database {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] | lower }},{{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower }}';"
        when: (fsfo_targets | lower ) != ( hostvars[groups[ primary ][0]]['database_primary_sid'] + "," + hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower )
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"
     
- name: Steps on Primary Only
  when: inventory_hostname == groups[ primary ][0]
  block:

      - name: Set FSFO Mode
        include: set-fsfo-mode.yml
        vars:
           delegation_host: "{{ groups[ primary ][0] }}"

      # The currently preferred active target is the first FastStartFailoverTarget on the primary
      - name: Set Active Target 
        include: set-fsfo-active-target.yml
        vars:
           delegation_host: "{{ groups[ primary ][0] }}"
           preferred_active_target: "{{ hostvars[groups[ primary ][0]]['fsfo_targets'].split(',')[0] | lower | trim }}"
           
- name: Start Observers if Not Running
  include: start-observer.yml
