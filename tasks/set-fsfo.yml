- name: Steps on Primary Only
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  block:

      - name: Get Configuration Name
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / "show configuration;" | grep "^Configuration - " | cut -f3 -d' '
        register: get_ConfigurationName
        changed_when: false

      - name: Set Configuration Name
        set_fact:
            configuration_name: "{{ get_ConfigurationName.stdout | trim }}"

      - name: Get Configuration-Wide Service Name
        shell: |
              . ~/.bash_profile
              dgmgrl  / "show configuration ConfigurationWideServiceName" | awk -F= '{print $2}'
        register: get_ConfigurationWideServiceName
        changed_when: false

      - name: Set Configuration-Wide Service Name
        set_fact:
            configuration_wide_service_name: "{{ get_ConfigurationWideServiceName.stdout_lines[-1] | default('') | replace(\"'\",'') |  trim }}"
        
      # Do not use configuration_wide_service_name in the when conditition as it will mutate before the end of the block
      - name: Fix Undefined Configuration-Wide Service Name
        when: ( get_ConfigurationWideServiceName.stdout_lines[-1] | default('') | replace("'",'') |  trim ) == ''
        block:

            - name: Set New Configuration-Wide Service Name
              set_fact:
                  configuration_wide_service_name: "{{ database_primary_unique }}_CFG"

            - name: Configure Configuration-Wide Service Name
              shell: |
                    . ~/.bash_profile
                    dgmgrl  / "edit configuration set property ConfigurationWideServiceName='{{ configuration_wide_service_name }}'"

- name: (main/set-primary-config) Handle if using tag InventoryHost as the inventory hostname
  set_fact:
    standby1: "{{ primary  | regex_replace('(.*)_primarydb$','\\1_standbydb1') }}"
    standby2: "{{ primary  | regex_replace('(.*)_primarydb$','\\1_standbydb2') }}"

- name: (main/set-primary-config) Handle if using tag InventoryHost as the inventory hostname
  set_fact:
    primary_host_tns: "{{  hostvars[groups[ primary ][0]]['inventory_hostname']  | regex_replace('([^\\.]*).*$' ,'\\1') | regex_replace('^(.+)-((delius|mis|misboe|misdsd)-db-(1|2|3))$','\\2') }}.{{ simple_environment_name }}.{{ project_name }}.{{ ansible_dns.search[0] }}"
    standby_host1_tns: "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname']  | regex_replace('([^\\.]*).*$' ,'\\1') | regex_replace('^(.+)-((delius|mis|misboe|misdsd)-db-(1|2|3))$','\\2') }}.{{ simple_environment_name }}.{{ project_name }}.{{ ansible_dns.search[0] }}"
    standby_host2_tns: "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname']  | regex_replace('([^\\.]*).*$' ,'\\1') | regex_replace('^(.+)-((delius|mis|misboe|misdsd)-db-(1|2|3))$','\\2') }}.{{ simple_environment_name }}.{{ project_name }}.{{ ansible_dns.search[0] }}"

- name: Add Optional HA1 TNS Address
  set_fact:
     ha1_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host1_tns }})(PORT = 1521))"
  when: (high_availability_count | int | default(0)) >= 1 

- name: Add Optional HA2 TNS Address
  set_fact:
     ha2_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host2_tns }})(PORT = 1521))"
  when: (high_availability_count | int | default(0)) == 2 

- name: Add Configuration-Wide Service TNS Names Alias
  blockinfile:
    create: yes
    path: '{{ oracle_database_oracle_home }}/network/admin/tnsnames.ora'  
    block: |

      {{ configuration_wide_service_name }} =
      (DESCRIPTION =
        (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = TCP)(HOST = {{ primary_host_tns }})(PORT = 1521)){{ ha1_address | default('') }}{{ ha2_address | default('') }})
              (CONNECT_DATA =
                (SERVER = DEDICATED) 
                (SERVICE_NAME = {{ configuration_wide_service_name }})
           )
       )
    owner: "{{ rdbms_service_user.name }}"
    group: "{{ rdbms_service_user.group }}"
    marker: "# {mark} ANSIBLE MANAGED BLOCK ADD CONFIGURATION-WIDE SERVICE NAME"

- name: Get Oracle Base
  shell: |
    . ~/.bash_profile
    echo $ORACLE_BASE
  register: oracle_base_result
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  changed_when: false  

- name: Set Oracle Base
  set_fact: 
    oracle_base: "{{ oracle_base_result.stdout }}"

- name: Define Location for Oracle Wallet
  set_fact:
    wallet_dir: "{{ oracle_base }}/wallets/dg_wallet"
  
- name: Create Wallet Directory
  file: 
    path: "{{ wallet_dir }}"
    state: directory

- name: Create Wallet if it does not already exist
  shell: |
        . ~/.bash_profile
        orapki wallet create -wallet {{ wallet_dir }} -auto_login_only
  args:
    creates: "{{ wallet_dir }}/cwallet.sso"
  register: orapki_out

- name: Check if the Configuration-Wide Service Name is Already in the Wallet
  shell: |
          . ~/.bash_profile
          mkstore -wrl {{ wallet_dir }} -listCredential | grep -c ": {{ configuration_wide_service_name }} sys$" | cat
  register: get_configuration_wide_service_name_in_wallet
  changed_when: false

- name: Add Wallet Location to SQLNET Config
  blockinfile:
    create: yes
    path: '{{ oracle_database_oracle_home }}/network/admin/sqlnet.ora'  
    block: |

      WALLET_LOCATION=(SOURCE=(METHOD=file)(METHOD_DATA=(DIRECTORY={{ wallet_dir }})))
      SQLNET.WALLET_OVERRIDE=true

    owner: "{{ rdbms_service_user.name }}"
    group: "{{ rdbms_service_user.group }}"
    marker: "# {mark} ANSIBLE MANAGED BLOCK ADD DATA GUARD WALLET"

- name: If Credential Exists Check that it Works
  shell: |
          . ~/.bash_profile
          echo exit | sqlplus -S -L /@{{ configuration_wide_service_name }} as sysdba
  register: check_password
  ignore_errors: True
  when: ( get_configuration_wide_service_name_in_wallet.stdout | int ) > 0

- name: Get sys password from ssm parameter store
  shell: . /etc/environment && aws ssm get-parameters --region ${REGION} --with-decryption --name /${HMPPS_ENVIRONMENT}/${APPLICATION}/${HMPPS_ROLE}-database/db/oradb_sys_password | jq -r '.Parameters[].Value'
  register: get_sys_password
  changed_when: false

- name: Initialize List of Data Guard Credentials
  set_fact:
      data_guard_credentials: "{{ [hostvars[groups[ primary ][0]]['database_primary_unique'] + '_CFG', hostvars[groups[ primary ][0]]['database_primary_unique']] }}"

- name: Add 1st Standby to Credentials List Where it Exists
  set_fact:
      data_guard_credentials: "{{ data_guard_credentials + [ hostvars[groups[ standby1 ][0]]['database_standby_unique'] ] }}"
  when: high_availability_count | int >= 1

- name: Add Optional 2nd Standby to Credentials List Where it Exists
  set_fact:
      data_guard_credentials: "{{ data_guard_credentials + [ hostvars[groups[ standby2 ][0]]['database_standby_unique']  ] }}"
  when: high_availability_count | int == 2

- debug: var=data_guard_credentials

- name: Initialize Password Update Count
  set_fact:
      password_update_count: 0

- name: Update Password in Data Guard Wallet
  include: update_data_guard_wallet_credentials.yml
  vars:
    credential_name: "{{ item }}"
    sys_password: "{{ get_sys_password.stdout }}"
  loop: "{{ data_guard_credentials }}"    

- name: Define Location for Observer Configuration
  set_fact:
      observer_config_dir: "{{ oracle_base }}/dg_observer"

- name: Create Observer Configuration Directory
  file:
      path: "{{ observer_config_dir }}"
      state: directory

- name: Install Observer Configuration File
  template:
    src: observer.j2
    dest: "{{ observer_config_dir }}/observer.ora"

# We require the hostname (EC2 Hostname) as supplied by the hostname command as this is what is used by the Data Guard Broker to identify hosts
- name: Get Hostname
  shell: |
         hostname
  register: get_hostname
  changed_when: false

- name: Set Hostname
  set_fact:
      my_hostname: "{{ get_hostname.stdout }}"

- name: Install CRS Resource Action Script to Control the Observer
  copy:
    src: observer.sh
    dest: "{{ observer_config_dir }}/observer.sh"
    mode: u+rw
  
- name: Install CRS Resource Attributes for Observer
  template:
    src: observer.config.j2
    dest: "{{ observer_config_dir }}/observer.config"
  vars:
    observer_script: "{{ observer_config_dir }}/observer.sh"
    ec2_hostname: "{{ my_hostname }}"
    db_service: "{{ database_primary_sid | default(database_standby_sid) | lower }}"

- name: Define Name for CRS Resource for Observer
  set_fact:
      observer_resource: "dg.observer"

- name: Check if CRS Resource Already Exists
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl status resource {{ observer_resource }} -p
  changed_when: false
  register: get_crs_resource

- name: Add CRS Resource for Observer
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl add resource {{ observer_resource }} -type cluster_resource -file {{ observer_config_dir }}/observer.config
  when: get_crs_resource.stdout is search('.*CRS-2613.*')

# Whilst we are working on configuring / resetting the Observers we want to temporarily remove them from the control of CRS
# so that it does not attempt to restart the resources at a time not of our choosing
- name: Disable CRS Resource for Observer
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl modify resource {{ observer_resource }} -attr "ENABLED=0"
  when: get_crs_resource.stdout is search('.*CRS-2613.*') or not "ENABLED=0" in get_crs_resource.stdout_lines

- name: Steps on Primary Only
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  block:

      - name: Get Existing FSFO Health Conditions
        shell: |
                . ~/.bash_profile
                dgmgrl  / "show fast_start failover;" | awk '{if(flag==1){print $0}}/Health Conditions:/{flag=1}/^$/{flag=0}'
        register: get_fsfo_health_conditions
        changed_when: false

      - name: Generate Dictionary of FSFO Health Conditions
        set_fact:
            current_fsfo_health_conditions: "{{ current_fsfo_health_conditions | default({}) | combine({ ( item | regex_replace('(YES|NO)$','') | trim ) : ( item | regex_replace('^.*(YES|NO)$','\\1') ) }) }}"
        loop: "{{ get_fsfo_health_conditions.stdout_lines }}"

      - name: Enable Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'enable fast_start failover condition "{{ item }}";'
        loop:  "{{ target_fsfo_health_conditions | default([]) }}"
        when: 
          - (current_fsfo_health_conditions[item] | default('NO')) != 'YES'

      - name: Disable Unwanted Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'disable fast_start failover condition "{{ item }}";'
        loop:  "{{ current_fsfo_health_conditions.keys() }}"
        when:  
          - item not in ( target_fsfo_health_conditions | default([]) )
          - (current_fsfo_health_conditions[item] | default('NO')) == 'YES'

      - name: Get Observer Reconnection Attempt Interval
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration ObserverReconnect;' | awk -F= '{print $2}'
        register: get_ObserverReconnect
        changed_when: false

      - name: Set Observer Reconnection Attempt Interval
        set_fact:
            current_observer_reconnect: "{{ get_ObserverReconnect.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

      - name: Configure Observer Reconnection Attempt Interval
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set property ObserverReconnect = {{ target_fsfo_observer_reconnect }};'
        when: ( target_fsfo_observer_reconnect | int ) != ( current_observer_reconnect | int )

      # All databases which have a standby are run in Maximum Availability Mode
      - name: Get Protection Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration;' | awk -F: '/Protection Mode/{print $2}'
        register: get_ProtectionMode
        changed_when: false      

      - name: Set Protection Mode
        set_fact:
            current_protection_mode: "{{ get_ProtectionMode.stdout_lines[-1] |  trim }}"

      - name: Configure Protection Mode
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set protection mode as maxavailability;'
        when: current_protection_mode != 'MaxAvailability'

- name: Get FSFO Targets
  shell: |
          . ~/.bash_profile
           dgmgrl -silent / "show database verbose {{ database_primary_sid | default(database_standby_sid) }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
  register: get_FastStartFailoverTarget
  changed_when: false

- name: Set FSFO Targets
  set_fact:
      current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

- name: Get Databases Currently in Configuration
  shell: |
         . ~/.bash_profile
         dgmgrl  / "show configuration;" | awk '/.* - .*database/{if(flag==1){print $0}}/Members:/{flag=1}/^Fast-Start Failover/{flag=0}'
  register: get_databases_in_configuration
  delegate_to: "{{ groups[ primary ][0] }}"
  changed_when: false
  run_once: yes

# List Index 0=Primary 1=1st Standby 2=2nd Standby
- name: Create List of Databases in Configuration
  set_fact:
      databases_in_configuration: "{{ databases_in_configuration | default([]) + [ item.split('-')[0] | trim ] }}"
  loop: "{{ get_databases_in_configuration.stdout_lines }}"
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: yes

- name: Determine Expected FSFO Targets Depending on Configuration
  block:

      - name: Determine Required FSFO Targets for Primary (Single Standby)
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[1] }}"
        when: 
          - inventory_hostname in groups[ primary ]
          - ( databases_in_configuration | length | int ) < 3

      - name: Determine Required FSFO Targets for Primary (Double Standby)
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[1] }},{{ databases_in_configuration[2] }}"
        when: 
          - inventory_hostname in groups[ primary ]
          - ( databases_in_configuration | length ) == 3
          - databases_in_configuration[1] < databases_in_configuration[2]

      - name: Determine Required FSFO Targets for Primary (Double Standby)
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[2] }},{{ databases_in_configuration[1] }}"
        when: 
          - inventory_hostname in groups[ primary ]
          - ( databases_in_configuration | length ) == 3
          - databases_in_configuration[2] < databases_in_configuration[1]

      - name: Determine Required FSFO Target (Primary) for New First Standby
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[0] }}"
        when: 
          - inventory_hostname in ( groups[ standby1 ] + groups[ standby2 ] )
          - ( databases_in_configuration | length | int ) < 3

      # If we have added a second standby then the FSFO target should be the primary and the *other* standby
      - name: Determine Required FSFO Target (Primary,1st Standby) for New Second Standby
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[0] }},{{ databases_in_configuration[1] }}"
        when: 
          - inventory_hostname in ( groups[ standby1 ] + groups[ standby2 ] )
          - ( database_standby_sid | lower ) != ( databases_in_configuration[1] | lower )
          - ( databases_in_configuration | length | int ) == 3

      - name: Determine Required FSFO Target (Primary,2nd Standby) for New Second Standby
        set_fact:
          fsfo_targets: "{{  databases_in_configuration[0] }},{{ databases_in_configuration[2] }}"
        when: 
          - inventory_hostname in ( groups[ standby1 ] + groups[ standby2 ] )
          - ( database_standby_sid | lower ) != ( databases_in_configuration[2] | lower )
          - ( databases_in_configuration | length | int ) == 3
     
- name: Configure FSFO Targets (New Standby)
  shell: |
         . ~/.bash_profile
         dgmgrl / "edit database {{ database_primary_sid | default(database_standby_sid) }} set property FastStartFailoverTarget='{{ fsfo_targets }}';"
  when: (fsfo_targets | lower ) != ( current_fsfo_targets | lower )

# If we have just added a new 2nd Standby it should be added as a Failover option to an existing 1st Standby
- name: Add New 2nd Standby as Failover Option for Existing 1st Standby
  when: 
     - standby_number == 2
     - hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration
  run_once: yes
  block:

      - name: Get FSFO Targets
        shell: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }};" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 1st Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl / "edit database {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }}';"
        when: (fsfo_targets | lower ) != (  hostvars[groups[ primary ][0]]['database_primary_sid'] + "," + hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower )
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"


# If we have just added a new 1st Standby it should be added as a Failover option to an existing 2nd Standby
# This block is unlikely to be called much.   It will only be called under the scenario that the 1st standby has been lost
# but the 2nd standby is still available, and the 1st standby is now being rebuilt
- name: Add New 1st Standby as Failover Option for Existing 2nd Standby
  when: 
     - standby_number == 1
     - hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower in databases_in_configuration
  run_once: yes
  block:

      - name: Get FSFO Targets
        shell: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 2nd Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl  -silent / "edit database {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }}';"
        when: (fsfo_targets | lower ) != ( hostvars[groups[ primary ][0]]['database_primary_sid'] + "," + hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower )
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"



# Now Set up Observers for FSFO
- name: Check Observers from Primary
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  block:

      - name: Get Location of Observers
        script: get_observer_hosts.sh "{{ observer_config_dir }}/observer.ora"
        register: get_observer_hosts
        changed_when: false

      - name: Initialize Observer List
        set_fact:
            observer_dict: {}

      # When run in CodeBuild the output of the get_observer_hosts.sh script includes the Ansible BECOME-SUCCESS marker when there are no Observers for unclear reasons.
      # This does not happen when run locally so is difficult to debug.   As a workaround we simply ignore the output if it contains BECOME-SUCCESS-
      # This marker does not appear when Observers do exist.
      - name: Populate Observer Dictionary
        set_fact:
            observer_dict: "{{ observer_dict | combine({item.split(' ')[0]: {'observer_name': item.split(' ')[0], 'type': item.split(' ')[1], 'hostname': item.split(' ')[2]}}) }}"
        loop: "{{ get_observer_hosts.stdout_lines | default([]) }}"
        when: not get_observer_hosts.stdout is search ("BECOME-SUCCESS-")

      - name: Stop Any Backup Observers Co-Located on Master (Want Only One per AZ)
        shell: |
              . ~/.bash_profile        
              dgmgrl / "stop observer {{ item }};"
              sleep 10
        loop: "{{ observer_dict.keys() }}"
        register: stop_colocate_master
        when: 
            - observer_dict[item].type == 'Backup'
            - observer_dict[item].hostname == ( observer_dict | dict2items | json_query('[?value.type==`Master`].value.hostname') | first )

      # Stop Non-First Co-Located Observer (We do not want to stop both Observers when they running on one host - just one of them)
      - name: Stop Any Backup Observers Co-Located on Another Backup (Want Only One per AZ)
        shell: |
              . ~/.bash_profile
              dgmgrl / "stop observer {{ item }};"
              sleep 10
        loop: "{{ observer_dict.keys() }}"
        register: stop_colocate_backup
        when: 
            - observer_dict[item].type == 'Backup'
            - observer_dict[item].observer_name != ( observer_dict | dict2items | json_query('[?value.hostname==`' + observer_dict[item].hostname + '`].value.observer_name') | first )

# Even if we are running a build on Standby #2 we still need to know the hostname of Standby #1 as this is the preferred target
# for the Master Observer.    Therefore we gather this hostname explictly and delegate the fact.
- name: Get 1st Standby Hostname
  shell: | 
         hostname
  register: get_hostname_1st_standby
  delegate_to: "{{ groups[ standby1 ][0] }}"
  run_once: true
  changed_when: false

- debug:
    msg: "Hostname 1st Standby: {{ get_hostname_1st_standby.stdout }}"

- name: Set 1st Standby Hostname
  set_fact:
      my_hostname: "{{ get_hostname_1st_standby.stdout }}" 
  delegate_to: "{{ groups[ standby1 ][0] }}"    
  delegate_facts: true
  run_once: true

# If we need to stop the Master Observer to change the password, then we will need to disable Fast Start Failover first
- name: Disable Fast Start Failover
  shell: |
      . ~/.bash_profile
      dgmgrl / "disable fast_start failover;"
  when: 
     - my_hostname == ( observer_dict | dict2items | json_query('[?value.type==`Master`].value.hostname') | first | default('none') )
     - ( password_update_count | int ) > 0

- debug: 
     msg: "{{ observer_dict | dict2items | json_query('[?value.hostname==`' + my_hostname + '`].value.observer_name') | list }}"

# Stop all the Observers on this host if the password has been changed to then allow it to restart with the new password
# Note that the stopping of Observers can take a long time to complete
- name: Stop Observers if Password Changed
  script: stop_observer.sh "{{ observer_config_dir }}/observer.ora" "{{ item }}"
  loop: "{{ observer_dict | dict2items | json_query('[?value.hostname==`' + my_hostname + '`].value.observer_name') | list }}"
  when: 
    - ( password_update_count | int ) > 0
    - ( item | length ) > 1
  vars:
    ansible_aws_ssm_timeout: 600

# If any Observers have been stopped, refresh the dictionary of observers
- name: Refresh Observers After Stop
  when: stop_colocate_master.changed or stop_colocate_backup.changed or (( password_update_count | int ) > 0)
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  block:

      - name: Get Updated Location of Observers
        script: get_observer_hosts.sh "{{ observer_config_dir }}/observer.ora"
        register: get_observer_hosts
        changed_when: false

      - name: Re-Initialize Observer Dictionary
        set_fact:
            observer_dict: {}

      - name: Re-Populate Observer Dictionary
        set_fact:
            observer_dict: "{{ observer_dict | combine({item.split(' ')[0]: {'observer_name': item.split(' ')[0], 'type': item.split(' ')[1], 'hostname': item.split(' ')[2]}}) }}"
        loop: "{{ get_observer_hosts.stdout_lines | default([])  }}"
        when: not get_observer_hosts.stdout is search ("BECOME-SUCCESS")

      - debug: var=observer_dict

- name: Start 1st Standby Observer
  script: start_observing.sh "{{observer_config_dir }}/observer.ora" "{{ configuration_wide_service_name }}" "{{observer_config_dir }}/observer.log" "{{observer_config_dir }}/fsfo.dat"
  when: 
      - inventory_hostname in groups[ standby1 ]
      - standby_number | int >= 1
      - my_hostname not in ( observer_dict.values() | map(attribute='hostname') | list )

- name: Start 2nd Standby Observer
  script: start_observing.sh "{{observer_config_dir }}/observer.ora" "{{ configuration_wide_service_name }}" "{{observer_config_dir }}/observer.log" "{{observer_config_dir }}/fsfo.dat"
  when: 
      - inventory_hostname in groups[ standby2 ]
      - standby_number | int == 2
      - my_hostname not in ( observer_dict.values() | map(attribute='hostname') | list )

# Observer on Primary is not initially useful but may be required following switchover or failover.
# Set it to initially monitor the 1st Standby
- name: Start Primary Observer
  script: start_observing.sh "{{observer_config_dir }}/observer.ora" "{{ configuration_wide_service_name }}" "{{observer_config_dir }}/observer.log" "{{observer_config_dir }}/fsfo.dat"
  when: 
      - inventory_hostname in groups[ primary ]
      - my_hostname not in ( observer_dict.values() | map(attribute='hostname') | list )
    
- name: Steps on Primary Only
  delegate_to: "{{ groups[ primary ][0] }}"
  run_once: true
  block:

      - name: Get Fast-Start Failover Status
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "show configuration;" | awk -F: '/Fast-Start Failover/{print $2}'
        register: get_fast_start_failover
        changed_when: false

      # Prepare for Mode Change if Needed
      - name: Disble Fast-Start Failover
        shell: |
               . ~/.bash_profile
               dgmgrl -silent / "disable fast_start failover"
        when:
            - ( get_fast_start_failover.stdout | trim ) != 'Disabled'
            - ( (get_fast_start_failover.stdout is search("Observe-Only Mode")) and (fsfo_mode | lower == 'enabled') )
              or ( (not get_fast_start_failover.stdout is search("Observe-Only Mode")) and (fsfo_mode | lower == 'observe') )

      # Accept both 'observe' or 'observer' as a valid mode
      - name: Enable Observe-Only Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "enable fast_start failover observe only"
        when:
            - not get_fast_start_failover.stdout is search("Observe-Only Mode")
            - fsfo_mode | lower == 'observe' or fsfo_mode | lower == 'observer'

      - name: Enable FSFO Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "enable fast_start failover"
        when:
            - get_fast_start_failover.stdout is search("Observe-Only Mode") or get_fast_start_failover.stdout is search("Disabled")
            - fsfo_mode | lower == 'enabled'
      
      - name: Get Location of Master Observer
        script: get_master_observer_host.sh "{{ observer_config_dir }}/observer.ora"
        register: get_master_observer_host
        changed_when: false

      - debug:
           msg: "Master Observer Host: {{ get_master_observer_host.stdout | trim }}.   Target Master Observer Host: {{ hostvars[groups[ standby1 ][0]]['my_hostname'] }}"

      - name: Move Master Observer to 1st Standby
        script: set_master_observer_host.sh "{{ observer_config_dir }}/observer.ora" "{{ hostvars[groups[ standby1 ][0]]['my_hostname'] }}"
        when: 
           - ( get_master_observer_host.stdout | trim ) != ( hostvars[groups[ standby1 ][0]]['my_hostname'] | trim )
           - hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration

      - name: Move Master Observer to 2nd Standby if 1st Standby Not Available
        script: set_master_observer_host.sh "{{ observer_config_dir }}/observer.ora" "{{ hostvars[groups[ standby2 ][0]]['my_hostname'] }}"
        when: 
           - standby_number | int == 2
           - (get_master_observer_host.stdout | trim ) != ( hostvars[groups[ standby2 ][0]]['my_hostname']  | trim )
           - not hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration
           - hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower in databases_in_configuration
       
      # Depending on the order that Standby databases have been added to the configuation it is possible that the Active Target is not the same as the first one
      # specified by FastStartFailoverTarget.    If this is the case then it needs to be corrected, so that the preferred failover target is used.
        
      - name: Get Current Active Target
        shell: |
              . ~/.bash_profile
               dgmgrl -silent / "show fast_start failover;" | awk '/Active Target:/{print $3}'
        register: get_active_target
        changed_when: false

      - name: Set Preferred Active Target
        shell: |
               . ~/.bash_profile
               dgmgrl -silent / "set fast_start failover target to {{ fsfo_targets.split(',')[0] | lower }};"
        when: ( fsfo_targets.split(',')[0] | lower | trim ) != ( get_active_target.stdout | lower | trim )


# Now we have completed the set-up of the Observers (or Password Change) we can allow CRS to start managing their availability again.
# (This is required to ensure that Observers are restarted if the server is rebooted)
- name: Check if CRS Resource is Still Disabled
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl status resource {{ observer_resource }} -p
  changed_when: false
  register: get_crs_resource

- name: Restart and Check CRS Resource for Observer
  shell: |
        . ~/.bash_profile
        export ORACLE_SID=+ASM
        export ORAENV_ASK=NO
        . oraenv
        crsctl modify resource {{ observer_resource }} -attr "ENABLED=1"
        crsctl check resource {{ observer_resource }}
  when: not "ENABLED=1" in get_crs_resource.stdout_lines