- name: Get Configuration Name
  shell: |
         . ~/.bash_profile
         dgmgrl -silent  / "show configuration;" | grep "^Configuration - " | cut -f3 -d' '
  register: get_ConfigurationName
  changed_when: false

- name: Set Configuration Name
  set_fact:
      configuration_name: "{{ get_ConfigurationName.stdout | trim }}"

- name: Get Configuration-Wide Service Name
  shell: |
         . ~/.bash_profile
         dgmgrl  / "show configuration ConfigurationWideServiceName" | awk -F= '{print $2}'
  register: get_ConfigurationWideServiceName
  changed_when: false

- name: Set Configuration-Wide Service Name
  set_fact:
      configuration_wide_service_name: "{{ get_ConfigurationWideServiceName.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

- debug: var=high_availability_count

- name: (main/set-primary-config) Handle if using tag InventoryHost as the inventory hostname
  set_fact:
    standby1: "{{ primary  | regex_replace('(.*)_primarydb$','\\1_standbydb1') }}"
    standby2: "{{ primary  | regex_replace('(.*)_primarydb$','\\1_standbydb1') }}"

- name: (main/set-primary-config) Handle if using tag InventoryHost as the inventory hostname
  set_fact:
    standby_host1_tns: "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname']  | regex_replace('([^\\.]*).*$' ,'\\1') | regex_replace('^(.+)-((delius|mis|misboe|misdsd)-db-(1|2|3))$','\\2') }}.{{ simple_environment_name }}.{{ project_name }}.{{ ansible_dns.search[0] }}"
    standby_host2_tns: "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname']  | regex_replace('([^\\.]*).*$' ,'\\1') | regex_replace('^(.+)-((delius|mis|misboe|misdsd)-db-(1|2|3))$','\\2') }}.{{ simple_environment_name }}.{{ project_name }}.{{ ansible_dns.search[0] }}"

- name: Add Optional HA1 TNS Address
  set_fact:
     ha1_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host1_tns }})(PORT = 1521))"
  when: (high_availability_count | int | default(0)) >= 1 

- name: Add Optional HA2 TNS Address
  set_fact:
     ha2_address: "(ADDRESS = (PROTOCOL = TCP)(HOST = {{ standby_host2_tns }})(PORT = 1521))"
  when: (high_availability_count | int | default(0)) == 2 

- name: Add Configuration-Wide Service TNS Names Alias
  blockinfile:
    create: yes
    path: '{{ oracle_database_oracle_home }}/network/admin/tnsnames.ora'  
    block: |

      {{ configuration_wide_service_name }} =
      (DESCRIPTION =
        (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = TCP)(HOST = {{ primary_host_tns }})(PORT = 1521)){{ ha1_address | default('') }}{{ ha2_address | default('') }})
              (CONNECT_DATA =
                (SERVER = DEDICATED) 
                (SERVICE_NAME = {{ configuration_wide_service_name }})
           )
       )
    owner: "{{ rdbms_service_user.name }}"
    group: "{{ rdbms_service_user.group }}"
    marker: "# {mark} ANSIBLE MANAGED BLOCK ADD {{ configuration_wide_service_name }}"

- name: Get Oracle Base
  shell: |
    . ~/.bash_profile
    echo $ORACLE_BASE
  register: oracle_base_result
  changed_when: false  

- name: Set Oracle Base
  set_fact: 
    oracle_base: "{{ oracle_base_result.stdout }}"

- name: Define Location for Oracle Wallet
  set_fact:
    wallet_dir: "{{ oracle_base }}/wallets/dg_wallet"
  
- name: Create Wallet Directory
  file: 
    path: "{{ wallet_dir }}"
    state: directory

- name: Create Wallet if it does not already exist
  shell: |
        . ~/.bash_profile
        orapki wallet create -wallet {{ wallet_dir }} -auto_login_only
  args:
    creates: "{{ wallet_dir }}/cwallet.sso"
  register: orapki_out

- name: Check if the Configuration-Wide Service Name is Already in the Wallet
  shell: |
          . ~/.bash_profile
          mkstore -wrl {{ wallet_dir }} -listCredential | grep -c ": {{ configuration_wide_service_name }} sys$" | cat
  register: get_configuration_wide_service_name_in_wallet
  changed_when: false

- name: If Credential Exists Check that it Works
  shell: |
          . ~/.bash_profile
          echo exit | sqlplus -S -L /@{{ configuration_wide_service_name }} as sysdba
  register: check_password
  ignore_errors: True
  when: ( get_configuration_wide_service_name_in_wallet.stdout | int ) > 1

- name: Get sys password from ssm parameter store
  shell: . /etc/environment && aws ssm get-parameters --region ${REGION} --with-decryption --name /${HMPPS_ENVIRONMENT}/${APPLICATION}/${HMPPS_ROLE}-database/db/oradb_sys_password | jq -r '.Parameters[].Value'
  register: get_sys_password
  changed_when: false
  when: (( get_configuration_wide_service_name_in_wallet.stdout | int ) == 0) or (( check_password.rc | default(1)) > 0)

- name: Update Existing Wallet Credentials with New Password
  shell: |
          . ~/.bash_profile
          mkstore -wrl {{ wallet_dir }} -modifyCredential {{ configuration_wide_service_name }} sys {{ get_sys_password.stdout }}
  when:
      - ( get_configuration_wide_service_name_in_wallet.stdout | int ) > 1
      - ( check_password.rc | default(1)) > 0

- name: Add Configuration-Wide Service Credentials to Wallet
  shell: |
          . ~/.bash_profile
          mkstore -wrl {{ wallet_dir }} -createCredential {{ configuration_wide_service_name }} sys {{ get_sys_password.stdout }}
  when: ( get_configuration_wide_service_name_in_wallet.stdout | int ) == 0

- name: Define Location for Observer Configuration
  set_fact:
      observer_config_dir: "{{ oracle_base }}/dg_observer"

- name: Create Observer Configuration Directory
  file:
      path: "{{ observer_config_dir }}"
      state: directory

- name: Install Observer Configuration File
  template:
    src: observer.j2
    dest: "{{ observer_config_dir }}/observer.ora"

- name: Steps on Primary Only
  when: inventory_hostname in groups[ primary ]
  block:

      - name: Get Existing FSFO Health Conditions
        shell: |
                . ~/.bash_profile
                dgmgrl  / "show fast_start failover;" | awk '{if(flag==1){print $0}}/Health Conditions:/{flag=1}/^$/{flag=0}'
        register: get_fsfo_health_conditions
        changed_when: false

      - name: Generate Dictionary of FSFO Health Conditions
        set_fact:
            current_fsfo_health_conditions: "{{ current_fsfo_health_conditions | default({}) | combine({ ( item | regex_replace('(YES|NO)$','') | trim ) : ( item | regex_replace('^.*(YES|NO)$','\\1') ) }) }}"
        loop: "{{ get_fsfo_health_conditions.stdout_lines }}"

      - name: Enable Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'enable fast_start failover condition "{{ item }}";'
        loop:  "{{ target_fsfo_health_conditions | default([]) }}"
        when: 
          - (current_fsfo_health_conditions[item] | default('NO')) != 'YES'

      - name: Disable Unwanted Target FSFO Health Conditions
        shell: |
              . ~/.bash_profile
              dgmgrl  / 'disable fast_start failover condition "{{ item }}";'
        loop:  "{{ current_fsfo_health_conditions.keys() }}"
        when:  
          - item not in ( target_fsfo_health_conditions | default([]) )
          - (current_fsfo_health_conditions[item] | default('NO')) == 'YES'

      - name: Get Observer Reconnection Attempt Interval
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration ObserverReconnect;' | awk -F= '{print $2}'
        register: get_ObserverReconnect
        changed_when: false

      - name: Set Observer Reconnection Attempt Interval
        set_fact:
            current_observer_reconnect: "{{ get_ObserverReconnect.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

      - name: Configure Observer Reconnection Attempt Interval
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set property ObserverReconnect = {{ target_fsfo_observer_reconnect }};'
        when: ( target_fsfo_observer_reconnect | int ) != ( current_observer_reconnect )

      # All databases which have a standby are run in Maximum Availability Mode
      - name: Get Protection Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent  / 'show configuration;' | awk -F: '/Protection Mode/{print $2}'
        register: get_ProtectionMode
        changed_when: false      

      - name: Set Protection Mode
        set_fact:
            current_protection_mode: "{{ get_ProtectionMode.stdout_lines[-1] |  trim }}"

      - name: Configure Protection Mode
        shell: |               
              . ~/.bash_profile
              dgmgrl -silent  / 'edit configuration set protection mode as maxavailability;'
        when: current_protection_mode != 'MaxAvailability'

- name: Get FSFO Targets
  shell: |
          . ~/.bash_profile
           dgmgrl -silent / "show database verbose {{ database_primary_sid | default(database_standby_sid) }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
  register: get_FastStartFailoverTarget

- name: Set FSFO Targets
  set_fact:
      current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"

- name: Get Databases Currently in Configuration
  shell: |
         . ~/.bash_profile
         dgmgrl  / "show configuration;" | awk '{if(flag==1){print $0}}/Members:/{flag=1}/^$/{flag=0}'
  register: get_databases_in_configuration
  when: inventory_hostname in groups[ primary ]
  changed_when: false
  run_once: yes

# List Index 0=Primary 1=1st Standby 2=2nd Standby
- name: Create List of Databases in Configuration
  set_fact:
      databases_in_configuration: "{{ databases_in_configuration | default([]) + [ item.split('-')[0] | trim ] }}"
  loop: "{{ get_databases_in_configuration.stdout_lines }}"
  when: inventory_hostname in groups[ primary ]
  run_once: yes

- name: Determine Expected FSFO Targets Depending on Configuration
  block:

      - name: Determine Required FSFO Targets for Primary (Single Standby)
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[1] }}"
        when: 
          - inventory_hostname in groups[ primary ]
          - ( databases_in_configuration | length | int ) < 3

      - name: Determine Required FSFO Targets for Primary (Double Standby)
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[1] }},{{ databases_in_configuration[2] }}"
        when: 
          - inventory_hostname in groups[ primary ]
          - ( databases_in_configuration | length ) == 3

      - name: Determine Required FSFO Targets for New First Standby
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[0] }}"
        when: 
          - inventory_hostname in groups[ standby ]
          - ( databases_in_configuration | length | int ) < 3

      - name: Determine Required FSFO Targets for New Second Standby
        set_fact:
          fsfo_targets: "{{ databases_in_configuration[0] }},{{ databases_in_configuration[1] }}"
        when: 
          - inventory_hostname in groups[ standby ]
          - ( database_standby_sid | lower ) != ( databases_in_configuration[1] | lower )
          - ( databases_in_configuration | length | int ) == 3

      - name: Determine Required FSFO Targets for New Second Standby
        set_fact:
          fsfo_targets: "{{  databases_in_configuration[0] }},{{ databases_in_configuration[2] }}"
        when: 
          - inventory_hostname in groups[ standby ]
          - ( database_standby_sid | lower ) != ( databases_in_configuration[2] | lower )
          - ( databases_in_configuration | length | int ) == 3
     
- name: Configure FSFO Targets (New Standby)
  shell: |
         . ~/.bash_profile
         dgmgrl / "edit database {{ database_primary_sid | default(database_standby_sid) }} set property FastStartFailoverTarget='{{ fsfo_targets }}';"
  when: (fsfo_targets | lower ) != ( current_fsfo_targets | lower )

# If we have just added a new 2nd Standby it should be added as a Failover option to an existing 1st Standby
- name: Add New 2nd Standby as Failover Option for Existing 1st Standby
  when: 
     - standby_number == 2
     - hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration
  run_once: yes
  block:

      - name: Get FSFO Targets
        script: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }};" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 1st Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl / "edit database {{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }}';"
        when: (fsfo_targets | lower ) != (  "hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby2 ][0]]['database_standby_sid']" | lower )
        delegate_to:  "{{ hostvars[groups[ standby1 ][0]]['inventory_hostname'] }}"


# If we have just added a new 1st Standby it should be added as a Failover option to an existing 2nd Standby
# This block is unlikely to be called much.   It will only be called under the scenario that the 1st standby has been lost
# but the 2nd standby is still available, and the 1st standby is now being rebuilt
- name: Add New 1st Standby as Failover Option for Existing 2nd Standby
  when: 
     - standby_number == 1
     - hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower in databases_in_configuration
  run_once: yes
  block:

      - name: Get FSFO Targets
        script: |
                . ~/.bash_profile
                dgmgrl -silent / "show database verbose {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }}" | awk -F= '/FastStartFailoverTarget/{print $2}'
        register: get_FastStartFailoverTarget
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"

      - name: Set FSFO Targets
        set_fact:
            current_fsfo_targets: "{{ get_FastStartFailoverTarget.stdout_lines[-1] | replace(\"'\",'') |  trim }}"
  
      - name: Configure FSFO (Existing 2nd Standby)
        shell: |
               . ~/.bash_profile
               dgmgrl / "edit database {{ hostvars[groups[ standby2 ][0]]['database_standby_sid'] }} set property FastStartFailoverTarget='{{ hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby1 ][0]]['database_standby_sid'] }}';"
        when: (fsfo_targets | lower ) != (  "hostvars[groups[ primary ][0]]['database_primary_sid'] }},{{ hostvars[groups[ standby1 ][0]]['database_standby_sid']" | lower )
        delegate_to:  "{{ hostvars[groups[ standby2 ][0]]['inventory_hostname'] }}"

- name: Get Hostname of Observers
  script: get_observer_hosts.sh "{{ observer_config_dir }}/observer.ora"
  register: get_observer_hosts
  changed_when: false

- name: Start Observing on this Host
  script: start_observing.sh "{{observer_config_dir }}/observer.ora"
  when:  ( (inventory_hostname in groups[ primary ]) and (primary_host_tns not in get_observer_hosts.stdout_lines) ) or
         ( (inventory_hostname in groups[ standby ]) and (standby_number == '1') and (standby_host1_tns not in get_observer_hosts.stdout_lines) ) or
         ( (inventory_hostname in groups[ standby ]) and (standby_number == '2') and (standby_host2_tns not in get_observer_hosts.stdout_lines) )
         

- name: Steps on Primary Only
  when: inventory_hostname in groups[ primary ]
  block:

      - name: Get Fast-Start Failover Status
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "show configuration;" | awk -F: '/Fast-Start Failover/{print $2}'
        register: get_fast_start_failover
        changed_when: false

      # Prepare for Mode Change if Needed
      - name: Disble Fast-Start Failover
        shell: |
               . ~/.bash_profile
               dgmgrl -silent / "disable fast_start failover"
        when:
            - get_fast_start_failover.stdout | trim != 'Disabled'
            - ( (get_fast_start_failover.stdout is search("Observe-Only Mode")) and (fsfo_mode | lower == 'enabled') )
              or ( (not get_fast_start_failover.stdout is search("Observe-Only Mode")) and (fsfo_mode | lower == 'observe') )

      - name: Enable Observe-Only Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "enable fast start failover observe only"
        when:
            - not get_fast_start_failover.stdout is search("Observe-Only Mode")
            - fsfo_mode | lower == 'observe'

      - name: Enable FSFO Mode
        shell: |
              . ~/.bash_profile
              dgmgrl -silent / "enable fast start failover observe only"
        when:
            - get_fast_start_failover.stdout is search("Observe-Only Mode") or get_fast_start_failover.stdout is search("Disabled")
            - fsfo_mode | lower == 'enabled'
      
      - name: Get Location of Master Observer
        script: get_master_observer_host.sh "{{ observer_config_dir }}/observer.ora"
        register: get_master_observer_host
        changed_when: false

      - name: Move Master Observer to 1st Standby
        script: set_master_observer_host.sh "{{ observer_config_dir }}/observer.ora" {{ standby_host1_tns }}
        when: 
           - get_master_observer_host.stdout != standby_host1_tns
           - hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration

      - name: Move Master Observer to 2nd Standby if 1st Standby Not Available
        script: set_master_observer_host.sh "{{ observer_config_dir }}/observer.ora" {{ standby_host2_tns }}
        when: 
           - get_master_observer_host.stdout != standby_host2_tns
           - not hostvars[groups[ standby1 ][0]]['database_standby_sid'] | lower in databases_in_configuration
           - hostvars[groups[ standby2 ][0]]['database_standby_sid'] | lower in databases_in_configuration
       
# Must Run on Each Host Individually

# (1) Check if Observer is Running on this Host

# (2) Start Observing
